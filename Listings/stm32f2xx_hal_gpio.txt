; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\isp\obj\stm32f2xx_hal_gpio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\isp\obj\stm32f2xx_hal_gpio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\stm32f2xx_hal\Inc -I.\ISP\Src -I.\RTE\_ISP -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F2xx_DFP\2.10.0\Drivers\CMSIS\Device\ST\STM32F2xx\Include -D__UVISION_VERSION=528 -D_RTE_ -DSTM32F207xx --omf_browse=.\isp\obj\stm32f2xx_hal_gpio.crf stm32f2xx_hal\Src\stm32f2xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;301      */
;;;302    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  b5f0              PUSH     {r4-r7,lr}
;;;303    {
000002  460b              MOV      r3,r1
;;;304      uint32_t position = 0x00u;
000004  2100              MOVS     r1,#0
;;;305      uint32_t iocurrent;
;;;306      uint32_t tmp;
;;;307    
;;;308      /* Check the parameters */
;;;309      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;310      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;311    
;;;312      /* Configure the port pins */
;;;313      while ((GPIO_Pin >> position) != 0x00u)
000006  e08c              B        |L1.290|
                  |L1.8|
;;;314      {
;;;315        /* Get current io position */
;;;316        iocurrent = (GPIO_Pin) & (1uL << position);
000008  2501              MOVS     r5,#1
00000a  408d              LSLS     r5,r5,r1
00000c  ea050203          AND      r2,r5,r3
;;;317    
;;;318        if (iocurrent != 0x00u)
000010  2a00              CMP      r2,#0
000012  d07d              BEQ      |L1.272|
;;;319        {
;;;320          /*------------------------- EXTI Mode Configuration --------------------*/
;;;321          /* Clear the External Interrupt or Event for the current IO */
;;;322    
;;;323          tmp = SYSCFG->EXTICR[position >> 2u];
000014  4d46              LDR      r5,|L1.304|
000016  088e              LSRS     r6,r1,#2
000018  f8554026          LDR      r4,[r5,r6,LSL #2]
;;;324          tmp &= (0x0FuL << (4u * (position & 0x03u)));
00001c  078d              LSLS     r5,r1,#30
00001e  0f2e              LSRS     r6,r5,#28
000020  250f              MOVS     r5,#0xf
000022  40b5              LSLS     r5,r5,r6
000024  402c              ANDS     r4,r4,r5
;;;325          if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
000026  4d43              LDR      r5,|L1.308|
000028  42a8              CMP      r0,r5
00002a  d101              BNE      |L1.48|
00002c  2500              MOVS     r5,#0
00002e  e028              B        |L1.130|
                  |L1.48|
000030  4d41              LDR      r5,|L1.312|
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L1.58|
000036  2501              MOVS     r5,#1
000038  e023              B        |L1.130|
                  |L1.58|
00003a  4d40              LDR      r5,|L1.316|
00003c  42a8              CMP      r0,r5
00003e  d101              BNE      |L1.68|
000040  2502              MOVS     r5,#2
000042  e01e              B        |L1.130|
                  |L1.68|
000044  4d3e              LDR      r5,|L1.320|
000046  42a8              CMP      r0,r5
000048  d101              BNE      |L1.78|
00004a  2503              MOVS     r5,#3
00004c  e019              B        |L1.130|
                  |L1.78|
00004e  4d3d              LDR      r5,|L1.324|
000050  42a8              CMP      r0,r5
000052  d101              BNE      |L1.88|
000054  2504              MOVS     r5,#4
000056  e014              B        |L1.130|
                  |L1.88|
000058  4d3b              LDR      r5,|L1.328|
00005a  42a8              CMP      r0,r5
00005c  d101              BNE      |L1.98|
00005e  2505              MOVS     r5,#5
000060  e00f              B        |L1.130|
                  |L1.98|
000062  4d3a              LDR      r5,|L1.332|
000064  42a8              CMP      r0,r5
000066  d101              BNE      |L1.108|
000068  2506              MOVS     r5,#6
00006a  e00a              B        |L1.130|
                  |L1.108|
00006c  4d38              LDR      r5,|L1.336|
00006e  42a8              CMP      r0,r5
000070  d101              BNE      |L1.118|
000072  2507              MOVS     r5,#7
000074  e005              B        |L1.130|
                  |L1.118|
000076  4d37              LDR      r5,|L1.340|
000078  42a8              CMP      r0,r5
00007a  d101              BNE      |L1.128|
00007c  2508              MOVS     r5,#8
00007e  e000              B        |L1.130|
                  |L1.128|
000080  2509              MOVS     r5,#9
                  |L1.130|
000082  078e              LSLS     r6,r1,#30
000084  0f36              LSRS     r6,r6,#28
000086  40b5              LSLS     r5,r5,r6
000088  42a5              CMP      r5,r4
00008a  d121              BNE      |L1.208|
;;;326          {
;;;327            /* Clear EXTI line configuration */
;;;328            EXTI->IMR &= ~((uint32_t)iocurrent);
00008c  4d32              LDR      r5,|L1.344|
00008e  682d              LDR      r5,[r5,#0]
000090  4395              BICS     r5,r5,r2
000092  4e31              LDR      r6,|L1.344|
000094  6035              STR      r5,[r6,#0]
;;;329            EXTI->EMR &= ~((uint32_t)iocurrent);
000096  1d35              ADDS     r5,r6,#4
000098  682d              LDR      r5,[r5,#0]
00009a  4395              BICS     r5,r5,r2
00009c  1d36              ADDS     r6,r6,#4
00009e  6035              STR      r5,[r6,#0]
;;;330    
;;;331            /* Clear Rising Falling edge configuration */
;;;332            EXTI->RTSR &= ~((uint32_t)iocurrent);
0000a0  1d35              ADDS     r5,r6,#4
0000a2  682d              LDR      r5,[r5,#0]
0000a4  4395              BICS     r5,r5,r2
0000a6  1d36              ADDS     r6,r6,#4
0000a8  6035              STR      r5,[r6,#0]
;;;333            EXTI->FTSR &= ~((uint32_t)iocurrent);
0000aa  1d35              ADDS     r5,r6,#4
0000ac  682d              LDR      r5,[r5,#0]
0000ae  4395              BICS     r5,r5,r2
0000b0  1d36              ADDS     r6,r6,#4
0000b2  6035              STR      r5,[r6,#0]
;;;334    
;;;335            /* Configure the External Interrupt or event for the current IO */
;;;336            tmp = 0x0FuL << (4u * (position & 0x03u));
0000b4  078d              LSLS     r5,r1,#30
0000b6  0f2e              LSRS     r6,r5,#28
0000b8  250f              MOVS     r5,#0xf
0000ba  fa05f406          LSL      r4,r5,r6
;;;337            SYSCFG->EXTICR[position >> 2u] &= ~tmp;
0000be  4d1c              LDR      r5,|L1.304|
0000c0  088e              LSRS     r6,r1,#2
0000c2  f8555026          LDR      r5,[r5,r6,LSL #2]
0000c6  43a5              BICS     r5,r5,r4
0000c8  4e19              LDR      r6,|L1.304|
0000ca  088f              LSRS     r7,r1,#2
0000cc  f8465027          STR      r5,[r6,r7,LSL #2]
                  |L1.208|
;;;338          }
;;;339    
;;;340          /*------------------------- GPIO Mode Configuration --------------------*/
;;;341          /* Configure IO Direction in Input Floating Mode */
;;;342          GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2u));
0000d0  6805              LDR      r5,[r0,#0]
0000d2  004f              LSLS     r7,r1,#1
0000d4  2603              MOVS     r6,#3
0000d6  40be              LSLS     r6,r6,r7
0000d8  43b5              BICS     r5,r5,r6
0000da  6005              STR      r5,[r0,#0]
;;;343    
;;;344          /* Configure the default Alternate Function in current IO */
;;;345          GPIOx->AFR[position >> 3u] &= ~(0xFu << ((uint32_t)(position & 0x07u) * 4u));
0000dc  08ce              LSRS     r6,r1,#3
0000de  f1000520          ADD      r5,r0,#0x20
0000e2  f8555026          LDR      r5,[r5,r6,LSL #2]
0000e6  074e              LSLS     r6,r1,#29
0000e8  0ef7              LSRS     r7,r6,#27
0000ea  260f              MOVS     r6,#0xf
0000ec  40be              LSLS     r6,r6,r7
0000ee  43b5              BICS     r5,r5,r6
0000f0  08cf              LSRS     r7,r1,#3
0000f2  f1000620          ADD      r6,r0,#0x20
0000f6  f8465027          STR      r5,[r6,r7,LSL #2]
;;;346    
;;;347          /* Deactivate the Pull-up and Pull-down resistor for the current IO */
;;;348          GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
0000fa  68c5              LDR      r5,[r0,#0xc]
0000fc  004f              LSLS     r7,r1,#1
0000fe  2603              MOVS     r6,#3
000100  40be              LSLS     r6,r6,r7
000102  43b5              BICS     r5,r5,r6
000104  60c5              STR      r5,[r0,#0xc]
;;;349    
;;;350          /* Configure the default value IO Output Type */
;;;351          GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position);
000106  6846              LDR      r6,[r0,#4]
000108  2501              MOVS     r5,#1
00010a  408d              LSLS     r5,r5,r1
00010c  43ae              BICS     r6,r6,r5
00010e  e000              B        |L1.274|
                  |L1.272|
000110  e006              B        |L1.288|
                  |L1.274|
000112  6046              STR      r6,[r0,#4]
;;;352    
;;;353          /* Configure the default value for IO Speed */
;;;354          GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2u));
000114  6885              LDR      r5,[r0,#8]
000116  004f              LSLS     r7,r1,#1
000118  2603              MOVS     r6,#3
00011a  40be              LSLS     r6,r6,r7
00011c  43b5              BICS     r5,r5,r6
00011e  6085              STR      r5,[r0,#8]
                  |L1.288|
;;;355        }
;;;356    
;;;357        position++;
000120  1c49              ADDS     r1,r1,#1
                  |L1.290|
000122  fa23f501          LSR      r5,r3,r1              ;313
000126  2d00              CMP      r5,#0                 ;313
000128  f47faf6e          BNE      |L1.8|
;;;358      }
;;;359    }
00012c  bdf0              POP      {r4-r7,pc}
;;;360    
                          ENDP

00012e  0000              DCW      0x0000
                  |L1.304|
                          DCD      0x40013808
                  |L1.308|
                          DCD      0x40020000
                  |L1.312|
                          DCD      0x40020400
                  |L1.316|
                          DCD      0x40020800
                  |L1.320|
                          DCD      0x40020c00
                  |L1.324|
                          DCD      0x40021000
                  |L1.328|
                          DCD      0x40021400
                  |L1.332|
                          DCD      0x40021800
                  |L1.336|
                          DCD      0x40021c00
                  |L1.340|
                          DCD      0x40022000
                  |L1.344|
                          DCD      0x40013c00

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;513      */
;;;514    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;515    {
;;;516      /* Prevent unused argument(s) compilation warning */
;;;517      UNUSED(GPIO_Pin);
;;;518      /* NOTE: This function Should not be modified, when the callback is needed,
;;;519               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;520       */
;;;521    }
;;;522    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;498      */
;;;499    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;500    {
000002  4604              MOV      r4,r0
;;;501      /* EXTI line interrupt detected */
;;;502      if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
000004  4804              LDR      r0,|L3.24|
000006  6800              LDR      r0,[r0,#0]
000008  4020              ANDS     r0,r0,r4
00000a  b120              CBZ      r0,|L3.22|
;;;503      {
;;;504        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000c  4802              LDR      r0,|L3.24|
00000e  6004              STR      r4,[r0,#0]
;;;505        HAL_GPIO_EXTI_Callback(GPIO_Pin);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.22|
;;;506      }
;;;507    }
000016  bd10              POP      {r4,pc}
;;;508    
                          ENDP

                  |L3.24|
                          DCD      0x40013c14

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;176      */
;;;177    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  b578              PUSH     {r3-r6,lr}
;;;178    {
000002  4602              MOV      r2,r0
;;;179      uint32_t position = 0x00u;
000004  2300              MOVS     r3,#0
;;;180      uint32_t iocurrent;
;;;181      uint32_t temp;
;;;182    
;;;183      /* Check the parameters */
;;;184      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;185      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;186      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;187      assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;188    
;;;189      /* Configure the port pins */
;;;190      while (((GPIO_Init->Pin) >> position) != 0x00u)
000006  e0e0              B        |L4.458|
                  |L4.8|
;;;191      {
;;;192        /* Get current io position */
;;;193        iocurrent = (GPIO_Init->Pin) & (1uL << position);
000008  2601              MOVS     r6,#1
00000a  409e              LSLS     r6,r6,r3
00000c  680d              LDR      r5,[r1,#0]
00000e  ea050406          AND      r4,r5,r6
;;;194    
;;;195        if (iocurrent != 0x00u)
000012  2c00              CMP      r4,#0
000014  d073              BEQ      |L4.254|
;;;196        {
;;;197          /* In case of Output or Alternate function mode selection */
;;;198          if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
000016  684d              LDR      r5,[r1,#4]
000018  2d01              CMP      r5,#1
00001a  d008              BEQ      |L4.46|
00001c  684d              LDR      r5,[r1,#4]
00001e  2d02              CMP      r5,#2
000020  d005              BEQ      |L4.46|
;;;199             (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
000022  684d              LDR      r5,[r1,#4]
000024  2d11              CMP      r5,#0x11
000026  d002              BEQ      |L4.46|
000028  684d              LDR      r5,[r1,#4]
00002a  2d12              CMP      r5,#0x12
00002c  d113              BNE      |L4.86|
                  |L4.46|
;;;200          {
;;;201            /* Check the Speed parameter */
;;;202            assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;203            /* Configure the IO Speed */
;;;204            temp = GPIOx->OSPEEDR;
00002e  6890              LDR      r0,[r2,#8]
;;;205            temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
000030  005e              LSLS     r6,r3,#1
000032  2503              MOVS     r5,#3
000034  40b5              LSLS     r5,r5,r6
000036  43a8              BICS     r0,r0,r5
;;;206            temp |= (GPIO_Init->Speed << (position * 2u));
000038  005e              LSLS     r6,r3,#1
00003a  68cd              LDR      r5,[r1,#0xc]
00003c  40b5              LSLS     r5,r5,r6
00003e  4328              ORRS     r0,r0,r5
;;;207            GPIOx->OSPEEDR = temp;
000040  6090              STR      r0,[r2,#8]
;;;208    
;;;209            /* Configure the IO Output Type */
;;;210            temp = GPIOx->OTYPER;
000042  6850              LDR      r0,[r2,#4]
;;;211            temp &= ~(GPIO_OTYPER_OT0 << position) ;
000044  2501              MOVS     r5,#1
000046  409d              LSLS     r5,r5,r3
000048  43a8              BICS     r0,r0,r5
;;;212            temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
00004a  790d              LDRB     r5,[r1,#4]
00004c  f3c51500          UBFX     r5,r5,#4,#1
000050  409d              LSLS     r5,r5,r3
000052  4328              ORRS     r0,r0,r5
;;;213            GPIOx->OTYPER = temp;
000054  6050              STR      r0,[r2,#4]
                  |L4.86|
;;;214          }
;;;215    
;;;216          /* Activate the Pull-up or Pull down resistor for the current IO */
;;;217          temp = GPIOx->PUPDR;
000056  68d0              LDR      r0,[r2,#0xc]
;;;218          temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
000058  005e              LSLS     r6,r3,#1
00005a  2503              MOVS     r5,#3
00005c  40b5              LSLS     r5,r5,r6
00005e  43a8              BICS     r0,r0,r5
;;;219          temp |= ((GPIO_Init->Pull) << (position * 2u));
000060  005e              LSLS     r6,r3,#1
000062  688d              LDR      r5,[r1,#8]
000064  40b5              LSLS     r5,r5,r6
000066  4328              ORRS     r0,r0,r5
;;;220          GPIOx->PUPDR = temp;
000068  60d0              STR      r0,[r2,#0xc]
;;;221    
;;;222          /*--------------------- GPIO Mode Configuration ------------------------*/
;;;223          /* In case of Alternate function mode selection */
;;;224          if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
00006a  684d              LDR      r5,[r1,#4]
00006c  2d02              CMP      r5,#2
00006e  d002              BEQ      |L4.118|
000070  684d              LDR      r5,[r1,#4]
000072  2d12              CMP      r5,#0x12
000074  d113              BNE      |L4.158|
                  |L4.118|
;;;225          {
;;;226            /* Check the Alternate function parameters */
;;;227            assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
;;;228            assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
;;;229    
;;;230            /* Configure Alternate function mapped with the current IO */
;;;231            temp = GPIOx->AFR[position >> 3u];
000076  08de              LSRS     r6,r3,#3
000078  f1020520          ADD      r5,r2,#0x20
00007c  f8550026          LDR      r0,[r5,r6,LSL #2]
;;;232            temp &= ~(0xFu << ((position & 0x07u) * 4u));
000080  075d              LSLS     r5,r3,#29
000082  0eee              LSRS     r6,r5,#27
000084  250f              MOVS     r5,#0xf
000086  40b5              LSLS     r5,r5,r6
000088  43a8              BICS     r0,r0,r5
;;;233            temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
00008a  075e              LSLS     r6,r3,#29
00008c  0ef6              LSRS     r6,r6,#27
00008e  690d              LDR      r5,[r1,#0x10]
000090  40b5              LSLS     r5,r5,r6
000092  4328              ORRS     r0,r0,r5
;;;234            GPIOx->AFR[position >> 3u] = temp;
000094  08de              LSRS     r6,r3,#3
000096  f1020520          ADD      r5,r2,#0x20
00009a  f8450026          STR      r0,[r5,r6,LSL #2]
                  |L4.158|
;;;235          }
;;;236    
;;;237          /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
;;;238          temp = GPIOx->MODER;
00009e  6810              LDR      r0,[r2,#0]
;;;239          temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
0000a0  005e              LSLS     r6,r3,#1
0000a2  2503              MOVS     r5,#3
0000a4  40b5              LSLS     r5,r5,r6
0000a6  43a8              BICS     r0,r0,r5
;;;240          temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
0000a8  790d              LDRB     r5,[r1,#4]
0000aa  f0050503          AND      r5,r5,#3
0000ae  005e              LSLS     r6,r3,#1
0000b0  40b5              LSLS     r5,r5,r6
0000b2  4328              ORRS     r0,r0,r5
;;;241          GPIOx->MODER = temp;
0000b4  6010              STR      r0,[r2,#0]
;;;242    
;;;243          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;244          /* Configure the External Interrupt or event for the current IO */
;;;245          if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
0000b6  684d              LDR      r5,[r1,#4]
0000b8  f0055580          AND      r5,r5,#0x10000000
0000bc  f1b55f80          CMP      r5,#0x10000000
0000c0  d11d              BNE      |L4.254|
;;;246          {
;;;247            /* Enable SYSCFG Clock */
;;;248            __HAL_RCC_SYSCFG_CLK_ENABLE();
0000c2  bf00              NOP      
0000c4  2500              MOVS     r5,#0
0000c6  9500              STR      r5,[sp,#0]
0000c8  4d43              LDR      r5,|L4.472|
0000ca  682d              LDR      r5,[r5,#0]
0000cc  f4454580          ORR      r5,r5,#0x4000
0000d0  4e41              LDR      r6,|L4.472|
0000d2  6035              STR      r5,[r6,#0]
0000d4  4635              MOV      r5,r6
0000d6  682d              LDR      r5,[r5,#0]
0000d8  f4054580          AND      r5,r5,#0x4000
0000dc  9500              STR      r5,[sp,#0]
0000de  bf00              NOP      
0000e0  bf00              NOP      
;;;249    
;;;250            temp = SYSCFG->EXTICR[position >> 2u];
0000e2  4d3e              LDR      r5,|L4.476|
0000e4  089e              LSRS     r6,r3,#2
0000e6  f8550026          LDR      r0,[r5,r6,LSL #2]
;;;251            temp &= ~(0x0FuL << (4u * (position & 0x03u)));
0000ea  079d              LSLS     r5,r3,#30
0000ec  0f2e              LSRS     r6,r5,#28
0000ee  250f              MOVS     r5,#0xf
0000f0  40b5              LSLS     r5,r5,r6
0000f2  43a8              BICS     r0,r0,r5
;;;252            temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
0000f4  4d3a              LDR      r5,|L4.480|
0000f6  42aa              CMP      r2,r5
0000f8  d102              BNE      |L4.256|
0000fa  2500              MOVS     r5,#0
0000fc  e029              B        |L4.338|
                  |L4.254|
0000fe  e063              B        |L4.456|
                  |L4.256|
000100  4d38              LDR      r5,|L4.484|
000102  42aa              CMP      r2,r5
000104  d101              BNE      |L4.266|
000106  2501              MOVS     r5,#1
000108  e023              B        |L4.338|
                  |L4.266|
00010a  4d37              LDR      r5,|L4.488|
00010c  42aa              CMP      r2,r5
00010e  d101              BNE      |L4.276|
000110  2502              MOVS     r5,#2
000112  e01e              B        |L4.338|
                  |L4.276|
000114  4d35              LDR      r5,|L4.492|
000116  42aa              CMP      r2,r5
000118  d101              BNE      |L4.286|
00011a  2503              MOVS     r5,#3
00011c  e019              B        |L4.338|
                  |L4.286|
00011e  4d34              LDR      r5,|L4.496|
000120  42aa              CMP      r2,r5
000122  d101              BNE      |L4.296|
000124  2504              MOVS     r5,#4
000126  e014              B        |L4.338|
                  |L4.296|
000128  4d32              LDR      r5,|L4.500|
00012a  42aa              CMP      r2,r5
00012c  d101              BNE      |L4.306|
00012e  2505              MOVS     r5,#5
000130  e00f              B        |L4.338|
                  |L4.306|
000132  4d31              LDR      r5,|L4.504|
000134  42aa              CMP      r2,r5
000136  d101              BNE      |L4.316|
000138  2506              MOVS     r5,#6
00013a  e00a              B        |L4.338|
                  |L4.316|
00013c  4d2f              LDR      r5,|L4.508|
00013e  42aa              CMP      r2,r5
000140  d101              BNE      |L4.326|
000142  2507              MOVS     r5,#7
000144  e005              B        |L4.338|
                  |L4.326|
000146  4d2e              LDR      r5,|L4.512|
000148  42aa              CMP      r2,r5
00014a  d101              BNE      |L4.336|
00014c  2508              MOVS     r5,#8
00014e  e000              B        |L4.338|
                  |L4.336|
000150  2509              MOVS     r5,#9
                  |L4.338|
000152  079e              LSLS     r6,r3,#30
000154  0f36              LSRS     r6,r6,#28
000156  40b5              LSLS     r5,r5,r6
000158  4328              ORRS     r0,r0,r5
;;;253            SYSCFG->EXTICR[position >> 2u] = temp;
00015a  4d20              LDR      r5,|L4.476|
00015c  089e              LSRS     r6,r3,#2
00015e  f8450026          STR      r0,[r5,r6,LSL #2]
;;;254    
;;;255            /* Clear EXTI line configuration */
;;;256            temp = EXTI->IMR;
000162  4d28              LDR      r5,|L4.516|
000164  6828              LDR      r0,[r5,#0]
;;;257            temp &= ~(iocurrent);
000166  43a0              BICS     r0,r0,r4
;;;258            if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
000168  684d              LDR      r5,[r1,#4]
00016a  f4053580          AND      r5,r5,#0x10000
00016e  f5b53f80          CMP      r5,#0x10000
000172  d100              BNE      |L4.374|
;;;259            {
;;;260              temp |= iocurrent;
000174  4320              ORRS     r0,r0,r4
                  |L4.374|
;;;261            }
;;;262            EXTI->IMR = temp;
000176  4d23              LDR      r5,|L4.516|
000178  6028              STR      r0,[r5,#0]
;;;263    
;;;264            temp = EXTI->EMR;
00017a  1d2d              ADDS     r5,r5,#4
00017c  6828              LDR      r0,[r5,#0]
;;;265            temp &= ~(iocurrent);
00017e  43a0              BICS     r0,r0,r4
;;;266            if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
000180  684d              LDR      r5,[r1,#4]
000182  f4053500          AND      r5,r5,#0x20000
000186  f5b53f00          CMP      r5,#0x20000
00018a  d100              BNE      |L4.398|
;;;267            {
;;;268              temp |= iocurrent;
00018c  4320              ORRS     r0,r0,r4
                  |L4.398|
;;;269            }
;;;270            EXTI->EMR = temp;
00018e  4d1d              LDR      r5,|L4.516|
000190  1d2d              ADDS     r5,r5,#4
000192  6028              STR      r0,[r5,#0]
;;;271    
;;;272            /* Clear Rising Falling edge configuration */
;;;273            temp = EXTI->RTSR;
000194  1d2d              ADDS     r5,r5,#4
000196  6828              LDR      r0,[r5,#0]
;;;274            temp &= ~(iocurrent);
000198  43a0              BICS     r0,r0,r4
;;;275            if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
00019a  684d              LDR      r5,[r1,#4]
00019c  f4051580          AND      r5,r5,#0x100000
0001a0  f5b51f80          CMP      r5,#0x100000
0001a4  d100              BNE      |L4.424|
;;;276            {
;;;277              temp |= iocurrent;
0001a6  4320              ORRS     r0,r0,r4
                  |L4.424|
;;;278            }
;;;279            EXTI->RTSR = temp;
0001a8  4d16              LDR      r5,|L4.516|
0001aa  3508              ADDS     r5,r5,#8
0001ac  6028              STR      r0,[r5,#0]
;;;280    
;;;281            temp = EXTI->FTSR;
0001ae  1d2d              ADDS     r5,r5,#4
0001b0  6828              LDR      r0,[r5,#0]
;;;282            temp &= ~(iocurrent);
0001b2  43a0              BICS     r0,r0,r4
;;;283            if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
0001b4  684d              LDR      r5,[r1,#4]
0001b6  f4051500          AND      r5,r5,#0x200000
0001ba  f5b51f00          CMP      r5,#0x200000
0001be  d100              BNE      |L4.450|
;;;284            {
;;;285              temp |= iocurrent;
0001c0  4320              ORRS     r0,r0,r4
                  |L4.450|
;;;286            }
;;;287            EXTI->FTSR = temp;
0001c2  4d10              LDR      r5,|L4.516|
0001c4  350c              ADDS     r5,r5,#0xc
0001c6  6028              STR      r0,[r5,#0]
                  |L4.456|
;;;288          }
;;;289        }
;;;290    
;;;291        position++;
0001c8  1c5b              ADDS     r3,r3,#1
                  |L4.458|
0001ca  680d              LDR      r5,[r1,#0]            ;190
0001cc  40dd              LSRS     r5,r5,r3              ;190
0001ce  2d00              CMP      r5,#0                 ;190
0001d0  f47faf1a          BNE      |L4.8|
;;;292      }
;;;293    }
0001d4  bd78              POP      {r3-r6,pc}
;;;294    
                          ENDP

0001d6  0000              DCW      0x0000
                  |L4.472|
                          DCD      0x40023844
                  |L4.476|
                          DCD      0x40013808
                  |L4.480|
                          DCD      0x40020000
                  |L4.484|
                          DCD      0x40020400
                  |L4.488|
                          DCD      0x40020800
                  |L4.492|
                          DCD      0x40020c00
                  |L4.496|
                          DCD      0x40021000
                  |L4.500|
                          DCD      0x40021400
                  |L4.504|
                          DCD      0x40021800
                  |L4.508|
                          DCD      0x40021c00
                  |L4.512|
                          DCD      0x40022000
                  |L4.516|
                          DCD      0x40013c00

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;464      */
;;;465    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;466    {
000002  4602              MOV      r2,r0
;;;467      __IO uint32_t tmp = GPIO_LCKR_LCKK;
000004  f44f3080          MOV      r0,#0x10000
000008  9000              STR      r0,[sp,#0]
;;;468    
;;;469      /* Check the parameters */
;;;470      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;471    
;;;472      /* Apply lock key write sequence */
;;;473      tmp |= GPIO_Pin;
00000a  9800              LDR      r0,[sp,#0]
00000c  4308              ORRS     r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;474      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;475      GPIOx->LCKR = tmp;
000010  9800              LDR      r0,[sp,#0]
000012  61d0              STR      r0,[r2,#0x1c]
;;;476      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;477      GPIOx->LCKR = GPIO_Pin;
000014  61d1              STR      r1,[r2,#0x1c]
;;;478      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;479      GPIOx->LCKR = tmp;
000016  9800              LDR      r0,[sp,#0]
000018  61d0              STR      r0,[r2,#0x1c]
;;;480      /* Read LCKK register. This read is mandatory to complete key lock sequence */
;;;481      tmp = GPIOx->LCKR;
00001a  69d0              LDR      r0,[r2,#0x1c]
00001c  9000              STR      r0,[sp,#0]
;;;482    
;;;483      /* read again in order to confirm lock is active */
;;;484     if((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00u)
00001e  69d0              LDR      r0,[r2,#0x1c]
000020  f4003080          AND      r0,r0,#0x10000
000024  b108              CBZ      r0,|L5.42|
;;;485      {
;;;486        return HAL_OK;
000026  2000              MOVS     r0,#0
                  |L5.40|
;;;487      }
;;;488      else
;;;489      {
;;;490        return HAL_ERROR;
;;;491      }
;;;492    }
000028  bd08              POP      {r3,pc}
                  |L5.42|
00002a  2001              MOVS     r0,#1                 ;490
00002c  e7fc              B        |L5.40|
;;;493    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;383      */
;;;384    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;385    {
;;;386      GPIO_PinState bitstatus;
;;;387    
;;;388      /* Check the parameters */
;;;389      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;390    
;;;391      if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  6913              LDR      r3,[r2,#0x10]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L6.12|
;;;392      {
;;;393        bitstatus = GPIO_PIN_SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L6.14|
                  |L6.12|
;;;394      }
;;;395      else
;;;396      {
;;;397        bitstatus = GPIO_PIN_RESET;
00000c  2000              MOVS     r0,#0
                  |L6.14|
;;;398      }
;;;399      return bitstatus;
;;;400    }
00000e  4770              BX       lr
;;;401    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;439      */
;;;440    void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;441    {
;;;442      uint32_t odr;
;;;443    
;;;444      /* Check the parameters */
;;;445      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;446    
;;;447      /* get current Ouput Data Register value */
;;;448      odr = GPIOx->ODR;
000002  6942              LDR      r2,[r0,#0x14]
;;;449    
;;;450      /* Set selected pins that were at low level, and reset ones that were high */
;;;451      GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
000004  ea210302          BIC      r3,r1,r2
000008  ea020401          AND      r4,r2,r1
00000c  ea434304          ORR      r3,r3,r4,LSL #16
000010  6183              STR      r3,[r0,#0x18]
;;;452    }
000012  bd10              POP      {r4,pc}
;;;453    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;417      */
;;;418    void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  b10a              CBZ      r2,|L8.6|
;;;419    {
;;;420      /* Check the parameters */
;;;421      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;422      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;423    
;;;424      if(PinState != GPIO_PIN_RESET)
;;;425      {
;;;426        GPIOx->BSRR = GPIO_Pin;
000002  6181              STR      r1,[r0,#0x18]
000004  e001              B        |L8.10|
                  |L8.6|
;;;427      }
;;;428      else
;;;429      {
;;;430        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
000006  040b              LSLS     r3,r1,#16
000008  6183              STR      r3,[r0,#0x18]
                  |L8.10|
;;;431      }
;;;432    }
00000a  4770              BX       lr
;;;433    
                          ENDP


;*** Start embedded assembler ***

#line 1 "stm32f2xx_hal\\Src\\stm32f2xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f2xx_hal_gpio_c_ea787061____REV16|
#line 467 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___20_stm32f2xx_hal_gpio_c_ea787061____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f2xx_hal_gpio_c_ea787061____REVSH|
#line 482
|__asm___20_stm32f2xx_hal_gpio_c_ea787061____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f2xx_hal_gpio_c_ea787061____RRX|
#line 669
|__asm___20_stm32f2xx_hal_gpio_c_ea787061____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
